import { VectorStore } from "@langchain/core/vectorstores";
import { Document } from "@langchain/core/documents";
/**
 * A vector store using LibSQL/Turso for storage and retrieval.
 */
export class LibSQLVectorStore extends VectorStore {
    /**
     * Returns the type of vector store.
     * @returns {string} The string "libsql".
     */
    _vectorstoreType() {
        return "libsql";
    }
    /**
     * Initializes a new instance of the LibSQLVectorStore.
     * @param {EmbeddingsInterface} embeddings - The embeddings interface to use.
     * @param {Client} db - The LibSQL client instance.
     * @param {LibSQLVectorStoreArgs} options - Configuration options for the vector store.
     */
    constructor(embeddings, options) {
        super(embeddings, options);
        Object.defineProperty(this, "db", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "table", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "column", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.db = options.db;
        this.table = options.table || "vectors";
        this.column = options.column || "embedding";
    }
    /**
     * Adds documents to the vector store.
     * @param {Document[]} documents - The documents to add.
     * @returns {Promise<string[]>} The IDs of the added documents.
     */
    async addDocuments(documents) {
        const texts = documents.map(({ pageContent }) => pageContent);
        const embeddings = await this.embeddings.embedDocuments(texts);
        return this.addVectors(embeddings, documents);
    }
    /**
     * Adds vectors to the vector store.
     * @param {number[][]} vectors - The vectors to add.
     * @param {Document[]} documents - The documents associated with the vectors.
     * @returns {Promise<string[]>} The IDs of the added vectors.
     */
    async addVectors(vectors, documents) {
        const rows = vectors.map((embedding, idx) => ({
            content: documents[idx].pageContent,
            embedding: `[${embedding.join(",")}]`,
            metadata: JSON.stringify(documents[idx].metadata),
        }));
        const batchSize = 100;
        const ids = [];
        for (let i = 0; i < rows.length; i += batchSize) {
            const chunk = rows.slice(i, i + batchSize);
            const insertQueries = chunk.map((row) => `INSERT INTO ${this.table} (content, metadata, ${this.column}) VALUES (${row.content}, ${row.metadata}, vector(${row.embedding})) RETURNING id`);
            const results = await this.db.batch(insertQueries);
            for (const result of results) {
                if (result &&
                    result.rows &&
                    result.rows.length > 0 &&
                    result.rows[0].id != null) {
                    ids.push(result.rows[0].id.toString());
                }
            }
        }
        return ids;
    }
    /**
     * Performs a similarity search using a vector query and returns documents with their scores.
     * @param {number[]} query - The query vector.
     * @param {number} k - The number of results to return.
     * @returns {Promise<[Document, number][]>} An array of tuples containing the similar documents and their scores.
     */
    async similaritySearchVectorWithScore(query, k
    // filter is currently unused
    // filter?: this["FilterType"]
    ) {
        // Potential SQL injection risk if query vector is not properly sanitized.
        if (!query.every((num) => typeof num === "number" && !Number.isNaN(num))) {
            throw new Error("Invalid query vector: all elements must be numbers");
        }
        const queryVector = `[${query.join(",")}]`;
        const sql = `
      SELECT content, metadata, vector_distance_cos(${this.column}, vector(${queryVector})) AS distance
      FROM vector_top_k('${this.table}_idx', vector(${queryVector}), ${k})
      JOIN ${this.table} ON ${this.table}.rowid = id
    `;
        const results = await this.db.execute(sql);
        return results.rows.map((row) => {
            const metadata = JSON.parse(row.metadata);
            const doc = new Document({
                metadata,
                pageContent: row.content,
            });
            return [doc, row.distance];
        });
    }
    /**
     * Deletes vectors from the store.
     * @param {Object} params - Delete parameters.
     * @param {string[] | number[]} [params.ids] - The ids of the vectors to delete.
     * @returns {Promise<void>}
     */
    async delete(params) {
        if (!params.ids) {
            await this.db.execute(`DELETE FROM ${this.table}`);
            return;
        }
        const idsToDelete = params.ids.join(", ");
        await this.db.execute({
            sql: `DELETE FROM ${this.table} WHERE id IN (?)`,
            args: [idsToDelete],
        });
    }
    /**
     * Creates a new LibSQLVectorStore instance from texts.
     * @param {string[]} texts - The texts to add to the store.
     * @param {object[] | object} metadatas - The metadata for the texts.
     * @param {EmbeddingsInterface} embeddings - The embeddings interface to use.
     * @param {Client} dbClient - The LibSQL client instance.
     * @param {LibSQLVectorStoreArgs} [options] - Configuration options for the vector store.
     * @returns {Promise<LibSQLVectorStore>} A new LibSQLVectorStore instance.
     */
    static async fromTexts(texts, metadatas, embeddings, options) {
        const docs = texts.map((text, i) => {
            const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
            return new Document({ pageContent: text, metadata });
        });
        return LibSQLVectorStore.fromDocuments(docs, embeddings, options);
    }
    /**
     * Creates a new LibSQLVectorStore instance from documents.
     * @param {Document[]} docs - The documents to add to the store.
     * @param {EmbeddingsInterface} embeddings - The embeddings interface to use.
     * @param {Client} dbClient - The LibSQL client instance.
     * @param {LibSQLVectorStoreArgs} [options] - Configuration options for the vector store.
     * @returns {Promise<LibSQLVectorStore>} A new LibSQLVectorStore instance.
     */
    static async fromDocuments(docs, embeddings, options) {
        const instance = new this(embeddings, options);
        await instance.addDocuments(docs);
        return instance;
    }
}
